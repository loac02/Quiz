const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const cors = require('cors');
require('dotenv').config();

const app = express();
app.use(cors());

const server = http.createServer(app);
const io = new Server(server, {
  cors: {
    origin: "*", // In production, replace with your frontend URL
    methods: ["GET", "POST"]
  }
});

// Game State Storage (In-memory for simplicity)
const rooms = new Map();

/**
 * Room Structure:
 * {
 *   id: string,
 *   players: Player[],
 *   questions: Question[],
 *   currentQuestionIndex: number,
 *   phase: 'LOBBY' | 'PLAYING' | 'RESULT' | 'GAME_OVER',
 *   startTime: number
 * }
 */

const QUESTION_DURATION = 15;
const ROUND_RESULT_DURATION = 8;

io.on('connection', (socket) => {
  console.log(`User connected: ${socket.id}`);

  // Create a Room
  socket.on('create_room', ({ player, config }) => {
    const roomId = Math.random().toString(36).substring(2, 8).toUpperCase();
    
    rooms.set(roomId, {
      id: roomId,
      hostId: socket.id,
      players: [{ ...player, id: socket.id, score: 0, streak: 0 }],
      config: config,
      phase: 'LOBBY',
      questions: []
    });

    socket.join(roomId);
    socket.emit('room_created', { roomId });
    io.to(roomId).emit('update_players', rooms.get(roomId).players);
    console.log(`Room ${roomId} created by ${player.name}`);
  });

  // Join a Room
  socket.on('join_room', ({ roomId, player }) => {
    const room = rooms.get(roomId);
    
    if (!room) {
      socket.emit('error', 'Sala não encontrada');
      return;
    }

    if (room.phase !== 'LOBBY') {
      socket.emit('error', 'O jogo já começou');
      return;
    }

    if (room.players.length >= 8) {
      socket.emit('error', 'Sala cheia');
      return;
    }

    room.players.push({ ...player, id: socket.id, score: 0, streak: 0 });
    socket.join(roomId);
    
    io.to(roomId).emit('update_players', room.players);
    console.log(`${player.name} joined room ${roomId}`);
  });

  // Start Game
  socket.on('start_game', async ({ roomId, questions }) => {
    const room = rooms.get(roomId);
    if (!room || room.hostId !== socket.id) return;

    room.questions = questions; // Questions should be generated by host and sent, or generated here via API
    room.currentQuestionIndex = 0;
    room.phase = 'PLAYING';

    io.to(roomId).emit('game_started', { questions: room.questions });
    
    startRound(roomId);
  });

  // Handle Answer
  socket.on('submit_answer', ({ roomId, answerIndex }) => {
    const room = rooms.get(roomId);
    if (!room || room.phase !== 'PLAYING') return;

    const player = room.players.find(p => p.id === socket.id);
    if (!player) return;

    const currentQ = room.questions[room.currentQuestionIndex];
    const isCorrect = answerIndex === currentQ.correctAnswerIndex;
    
    // Calculate Score (simplified version of frontend logic)
    // In a real secure app, time calculation should happen here based on server start time
    if (isCorrect) {
      player.streak += 1;
      const basePoints = 100;
      const multiplier = Math.min(3, 1 + (player.streak * 0.5));
      player.score += Math.floor(basePoints * multiplier);
      player.lastAnswerCorrect = true;
    } else {
      player.streak = 0;
      player.lastAnswerCorrect = false;
    }

    // Notify room of live score update (optional, usually done at end of round)
    // io.to(roomId).emit('update_players', room.players); 
  });

  socket.on('disconnect', () => {
    console.log(`User disconnected: ${socket.id}`);
    // Cleanup logic: remove player from rooms, delete empty rooms, etc.
    rooms.forEach((room, roomId) => {
      const index = room.players.findIndex(p => p.id === socket.id);
      if (index !== -1) {
        room.players.splice(index, 1);
        io.to(roomId).emit('update_players', room.players);
        
        if (room.players.length === 0) {
          rooms.delete(roomId);
        }
      }
    });
  });
});

function startRound(roomId) {
  const room = rooms.get(roomId);
  if (!room) return;

  room.phase = 'PLAYING';
  io.to(roomId).emit('round_start', { 
    questionIndex: room.currentQuestionIndex,
    startTime: Date.now()
  });

  // Timer for Question
  setTimeout(() => {
    endRound(roomId);
  }, QUESTION_DURATION * 1000);
}

function endRound(roomId) {
  const room = rooms.get(roomId);
  if (!room) return;

  room.phase = 'RESULT';
  
  // Broadcast updated scores and correct answer
  io.to(roomId).emit('round_end', {
    players: room.players,
    correctAnswerIndex: room.questions[room.currentQuestionIndex].correctAnswerIndex
  });

  // Wait for result reading, then next question or game over
  setTimeout(() => {
    if (room.currentQuestionIndex < room.questions.length - 1) {
      room.currentQuestionIndex++;
      startRound(roomId);
    } else {
      room.phase = 'GAME_OVER';
      io.to(roomId).emit('game_over', { players: room.players });
    }
  }, ROUND_RESULT_DURATION * 1000);
}

const PORT = process.env.PORT || 3001;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});
